<?xml version="1.0" ?>
<testsuites name="trivy">
    <testsuite tests="30" failures="30" name="mohamed710/solar-system-gitea:62961a6bc2e8a26ec53be66fb435fe2773f8302e (alpine 3.17.6)" errors="0" skipped="0" time="">
        <properties>
            <property name="type" value="alpine"></property>
        </properties>
        <testcase classname="busybox-1.35.0-r29" name="[MEDIUM] CVE-2023-42363" time="">
            <failure message="busybox: use-after-free in awk" type="description">A use-after-free vulnerability was discovered in xasprintf function in xfuncs_printf.c:344 in BusyBox v.1.36.1.</failure>
        </testcase>
        <testcase classname="busybox-1.35.0-r29" name="[MEDIUM] CVE-2023-42364" time="">
            <failure message="busybox: use-after-free" type="description">A use-after-free vulnerability in BusyBox v.1.36.1 allows attackers to cause a denial of service via a crafted awk pattern in the awk.c evaluate function.</failure>
        </testcase>
        <testcase classname="busybox-1.35.0-r29" name="[MEDIUM] CVE-2023-42365" time="">
            <failure message="busybox: use-after-free" type="description">A use-after-free vulnerability was discovered in BusyBox v.1.36.1 via a crafted awk pattern in the awk.c copyvar function.</failure>
        </testcase>
        <testcase classname="busybox-1.35.0-r29" name="[MEDIUM] CVE-2023-42366" time="">
            <failure message="busybox: A heap-buffer-overflow" type="description">A heap-buffer-overflow was discovered in BusyBox v.1.36.1 in the next_token function at awk.c:1159.</failure>
        </testcase>
        <testcase classname="busybox-binsh-1.35.0-r29" name="[MEDIUM] CVE-2023-42363" time="">
            <failure message="busybox: use-after-free in awk" type="description">A use-after-free vulnerability was discovered in xasprintf function in xfuncs_printf.c:344 in BusyBox v.1.36.1.</failure>
        </testcase>
        <testcase classname="busybox-binsh-1.35.0-r29" name="[MEDIUM] CVE-2023-42364" time="">
            <failure message="busybox: use-after-free" type="description">A use-after-free vulnerability in BusyBox v.1.36.1 allows attackers to cause a denial of service via a crafted awk pattern in the awk.c evaluate function.</failure>
        </testcase>
        <testcase classname="busybox-binsh-1.35.0-r29" name="[MEDIUM] CVE-2023-42365" time="">
            <failure message="busybox: use-after-free" type="description">A use-after-free vulnerability was discovered in BusyBox v.1.36.1 via a crafted awk pattern in the awk.c copyvar function.</failure>
        </testcase>
        <testcase classname="busybox-binsh-1.35.0-r29" name="[MEDIUM] CVE-2023-42366" time="">
            <failure message="busybox: A heap-buffer-overflow" type="description">A heap-buffer-overflow was discovered in BusyBox v.1.36.1 in the next_token function at awk.c:1159.</failure>
        </testcase>
        <testcase classname="libcrypto3-3.0.12-r1" name="[HIGH] CVE-2024-6119" time="">
            <failure message="openssl: Possible denial of service in X.509 name checks" type="description">Issue summary: Applications performing certificate name checks (e.g., TLS&#xA;clients checking server certificates) may attempt to read an invalid memory&#xA;address resulting in abnormal termination of the application process.&#xA;&#xA;Impact summary: Abnormal termination of an application can a cause a denial of&#xA;service.&#xA;&#xA;Applications performing certificate name checks (e.g., TLS clients checking&#xA;server certificates) may attempt to read an invalid memory address when&#xA;comparing the expected name with an `otherName` subject alternative name of an&#xA;X.509 certificate. This may result in an exception that terminates the&#xA;application program.&#xA;&#xA;Note that basic certificate chain validation (signatures, dates, ...) is not&#xA;affected, the denial of service can occur only when the application also&#xA;specifies an expected DNS name, Email address or IP address.&#xA;&#xA;TLS servers rarely solicit client certificates, and even when they do, they&#xA;generally don&#39;t perform a name check against a reference identifier (expected&#xA;identity), but rather extract the presented identity after checking the&#xA;certificate chain.  So TLS servers are generally not affected and the severity&#xA;of the issue is Moderate.&#xA;&#xA;The FIPS modules in 3.3, 3.2, 3.1 and 3.0 are not affected by this issue.</failure>
        </testcase>
        <testcase classname="libcrypto3-3.0.12-r1" name="[MEDIUM] CVE-2023-6129" time="">
            <failure message="openssl: POLY1305 MAC implementation corrupts vector registers on PowerPC" type="description">Issue summary: The POLY1305 MAC (message authentication code) implementation&#xA;contains a bug that might corrupt the internal state of applications running&#xA;on PowerPC CPU based platforms if the CPU provides vector instructions.&#xA;&#xA;Impact summary: If an attacker can influence whether the POLY1305 MAC&#xA;algorithm is used, the application state might be corrupted with various&#xA;application dependent consequences.&#xA;&#xA;The POLY1305 MAC (message authentication code) implementation in OpenSSL for&#xA;PowerPC CPUs restores the contents of vector registers in a different order&#xA;than they are saved. Thus the contents of some of these vector registers&#xA;are corrupted when returning to the caller. The vulnerable code is used only&#xA;on newer PowerPC processors supporting the PowerISA 2.07 instructions.&#xA;&#xA;The consequences of this kind of internal application state corruption can&#xA;be various - from no consequences, if the calling application does not&#xA;depend on the contents of non-volatile XMM registers at all, to the worst&#xA;consequences, where the attacker could get complete control of the application&#xA;process. However unless the compiler uses the vector registers for storing&#xA;pointers, the most likely consequence, if any, would be an incorrect result&#xA;of some application dependent calculations or a crash leading to a denial of&#xA;service.&#xA;&#xA;The POLY1305 MAC algorithm is most frequently used as part of the&#xA;CHACHA20-POLY1305 AEAD (authenticated encryption with associated data)&#xA;algorithm. The most common usage of this AEAD cipher is with TLS protocol&#xA;versions 1.2 and 1.3. If this cipher is enabled on the server a malicious&#xA;client can influence whether this AEAD cipher is used. This implies that&#xA;TLS server applications using OpenSSL can be potentially impacted. However&#xA;we are currently not aware of any concrete application that would be affected&#xA;by this issue therefore we consider this a Low severity security issue.</failure>
        </testcase>
        <testcase classname="libcrypto3-3.0.12-r1" name="[MEDIUM] CVE-2023-6237" time="">
            <failure message="openssl: Excessive time spent checking invalid RSA public keys" type="description">Issue summary: Checking excessively long invalid RSA public keys may take&#xA;a long time.&#xA;&#xA;Impact summary: Applications that use the function EVP_PKEY_public_check()&#xA;to check RSA public keys may experience long delays. Where the key that&#xA;is being checked has been obtained from an untrusted source this may lead&#xA;to a Denial of Service.&#xA;&#xA;When function EVP_PKEY_public_check() is called on RSA public keys,&#xA;a computation is done to confirm that the RSA modulus, n, is composite.&#xA;For valid RSA keys, n is a product of two or more large primes and this&#xA;computation completes quickly. However, if n is an overly large prime,&#xA;then this computation would take a long time.&#xA;&#xA;An application that calls EVP_PKEY_public_check() and supplies an RSA key&#xA;obtained from an untrusted source could be vulnerable to a Denial of Service&#xA;attack.&#xA;&#xA;The function EVP_PKEY_public_check() is not called from other OpenSSL&#xA;functions however it is called from the OpenSSL pkey command line&#xA;application. For that reason that application is also vulnerable if used&#xA;with the &#39;-pubin&#39; and &#39;-check&#39; options on untrusted data.&#xA;&#xA;The OpenSSL SSL/TLS implementation is not affected by this issue.&#xA;&#xA;The OpenSSL 3.0 and 3.1 FIPS providers are affected by this issue.</failure>
        </testcase>
        <testcase classname="libcrypto3-3.0.12-r1" name="[MEDIUM] CVE-2024-0727" time="">
            <failure message="openssl: denial of service via null dereference" type="description">Issue summary: Processing a maliciously formatted PKCS12 file may lead OpenSSL&#xA;to crash leading to a potential Denial of Service attack&#xA;&#xA;Impact summary: Applications loading files in the PKCS12 format from untrusted&#xA;sources might terminate abruptly.&#xA;&#xA;A file in PKCS12 format can contain certificates and keys and may come from an&#xA;untrusted source. The PKCS12 specification allows certain fields to be NULL, but&#xA;OpenSSL does not correctly check for this case. This can lead to a NULL pointer&#xA;dereference that results in OpenSSL crashing. If an application processes PKCS12&#xA;files from an untrusted source using the OpenSSL APIs then that application will&#xA;be vulnerable to this issue.&#xA;&#xA;OpenSSL APIs that are vulnerable to this are: PKCS12_parse(),&#xA;PKCS12_unpack_p7data(), PKCS12_unpack_p7encdata(), PKCS12_unpack_authsafes()&#xA;and PKCS12_newpass().&#xA;&#xA;We have also fixed a similar issue in SMIME_write_PKCS7(). However since this&#xA;function is related to writing data we do not consider it security significant.&#xA;&#xA;The FIPS modules in 3.2, 3.1 and 3.0 are not affected by this issue.</failure>
        </testcase>
        <testcase classname="libcrypto3-3.0.12-r1" name="[MEDIUM] CVE-2024-4603" time="">
            <failure message="openssl: Excessive time spent checking DSA keys and parameters" type="description">Issue summary: Checking excessively long DSA keys or parameters may be very&#xA;slow.&#xA;&#xA;Impact summary: Applications that use the functions EVP_PKEY_param_check()&#xA;or EVP_PKEY_public_check() to check a DSA public key or DSA parameters may&#xA;experience long delays. Where the key or parameters that are being checked&#xA;have been obtained from an untrusted source this may lead to a Denial of&#xA;Service.&#xA;&#xA;The functions EVP_PKEY_param_check() or EVP_PKEY_public_check() perform&#xA;various checks on DSA parameters. Some of those computations take a long time&#xA;if the modulus (`p` parameter) is too large.&#xA;&#xA;Trying to use a very large modulus is slow and OpenSSL will not allow using&#xA;public keys with a modulus which is over 10,000 bits in length for signature&#xA;verification. However the key and parameter check functions do not limit&#xA;the modulus size when performing the checks.&#xA;&#xA;An application that calls EVP_PKEY_param_check() or EVP_PKEY_public_check()&#xA;and supplies a key or parameters obtained from an untrusted source could be&#xA;vulnerable to a Denial of Service attack.&#xA;&#xA;These functions are not called by OpenSSL itself on untrusted DSA keys so&#xA;only applications that directly call these functions may be vulnerable.&#xA;&#xA;Also vulnerable are the OpenSSL pkey and pkeyparam command line applications&#xA;when using the `-check` option.&#xA;&#xA;The OpenSSL SSL/TLS implementation is not affected by this issue.&#xA;&#xA;The OpenSSL 3.0 and 3.1 FIPS providers are affected by this issue.</failure>
        </testcase>
        <testcase classname="libcrypto3-3.0.12-r1" name="[MEDIUM] CVE-2024-4741" time="">
            <failure message="openssl: Use After Free with SSL_free_buffers" type="description">Issue summary: Calling the OpenSSL API function SSL_free_buffers may cause&#xA;memory to be accessed that was previously freed in some situations&#xA;&#xA;Impact summary: A use after free can have a range of potential consequences such&#xA;as the corruption of valid data, crashes or execution of arbitrary code.&#xA;However, only applications that directly call the SSL_free_buffers function are&#xA;affected by this issue. Applications that do not call this function are not&#xA;vulnerable. Our investigations indicate that this function is rarely used by&#xA;applications.&#xA;&#xA;The SSL_free_buffers function is used to free the internal OpenSSL buffer used&#xA;when processing an incoming record from the network. The call is only expected&#xA;to succeed if the buffer is not currently in use. However, two scenarios have&#xA;been identified where the buffer is freed even when still in use.&#xA;&#xA;The first scenario occurs where a record header has been received from the&#xA;network and processed by OpenSSL, but the full record body has not yet arrived.&#xA;In this case calling SSL_free_buffers will succeed even though a record has only&#xA;been partially processed and the buffer is still in use.&#xA;&#xA;The second scenario occurs where a full record containing application data has&#xA;been received and processed by OpenSSL but the application has only read part of&#xA;this data. Again a call to SSL_free_buffers will succeed even though the buffer&#xA;is still in use.&#xA;&#xA;While these scenarios could occur accidentally during normal operation a&#xA;malicious attacker could attempt to engineer a stituation where this occurs.&#xA;We are not aware of this issue being actively exploited.&#xA;&#xA;The FIPS modules in 3.3, 3.2, 3.1 and 3.0 are not affected by this issue.</failure>
        </testcase>
        <testcase classname="libcrypto3-3.0.12-r1" name="[MEDIUM] CVE-2024-5535" time="">
            <failure message="openssl: SSL_select_next_proto buffer overread" type="description">Issue summary: Calling the OpenSSL API function SSL_select_next_proto with an&#xA;empty supported client protocols buffer may cause a crash or memory contents to&#xA;be sent to the peer.&#xA;&#xA;Impact summary: A buffer overread can have a range of potential consequences&#xA;such as unexpected application beahviour or a crash. In particular this issue&#xA;could result in up to 255 bytes of arbitrary private data from memory being sent&#xA;to the peer leading to a loss of confidentiality. However, only applications&#xA;that directly call the SSL_select_next_proto function with a 0 length list of&#xA;supported client protocols are affected by this issue. This would normally never&#xA;be a valid scenario and is typically not under attacker control but may occur by&#xA;accident in the case of a configuration or programming error in the calling&#xA;application.&#xA;&#xA;The OpenSSL API function SSL_select_next_proto is typically used by TLS&#xA;applications that support ALPN (Application Layer Protocol Negotiation) or NPN&#xA;(Next Protocol Negotiation). NPN is older, was never standardised and&#xA;is deprecated in favour of ALPN. We believe that ALPN is significantly more&#xA;widely deployed than NPN. The SSL_select_next_proto function accepts a list of&#xA;protocols from the server and a list of protocols from the client and returns&#xA;the first protocol that appears in the server list that also appears in the&#xA;client list. In the case of no overlap between the two lists it returns the&#xA;first item in the client list. In either case it will signal whether an overlap&#xA;between the two lists was found. In the case where SSL_select_next_proto is&#xA;called with a zero length client list it fails to notice this condition and&#xA;returns the memory immediately following the client list pointer (and reports&#xA;that there was no overlap in the lists).&#xA;&#xA;This function is typically called from a server side application callback for&#xA;ALPN or a client side application callback for NPN. In the case of ALPN the list&#xA;of protocols supplied by the client is guaranteed by libssl to never be zero in&#xA;length. The list of server protocols comes from the application and should never&#xA;normally be expected to be of zero length. In this case if the&#xA;SSL_select_next_proto function has been called as expected (with the list&#xA;supplied by the client passed in the client/client_len parameters), then the&#xA;application will not be vulnerable to this issue. If the application has&#xA;accidentally been configured with a zero length server list, and has&#xA;accidentally passed that zero length server list in the client/client_len&#xA;parameters, and has additionally failed to correctly handle a &#34;no overlap&#34;&#xA;response (which would normally result in a handshake failure in ALPN) then it&#xA;will be vulnerable to this problem.&#xA;&#xA;In the case of NPN, the protocol permits the client to opportunistically select&#xA;a protocol when there is no overlap. OpenSSL returns the first client protocol&#xA;in the no overlap case in support of this. The list of client protocols comes&#xA;from the application and should never normally be expected to be of zero length.&#xA;However if the SSL_select_next_proto function is accidentally called with a&#xA;client_len of 0 then an invalid memory pointer will be returned instead. If the&#xA;application uses this output as the opportunistic protocol then the loss of&#xA;confidentiality will occur.&#xA;&#xA;This issue has been assessed as Low severity because applications are most&#xA;likely to be vulnerable if they are using NPN instead of ALPN - but NPN is not&#xA;widely used. It also requires an application configuration or programming error.&#xA;Finally, this issue would not typically be under attacker control making active&#xA;exploitation unlikely.&#xA;&#xA;The FIPS modules in 3.3, 3.2, 3.1 and 3.0 are not affected by this issue.&#xA;&#xA;Due to the low severity of this issue we are not issuing new releases of&#xA;OpenSSL at this time. The fix will be included in the next releases when they&#xA;become available.</failure>
        </testcase>
        <testcase classname="libcrypto3-3.0.12-r1" name="[LOW] CVE-2024-2511" time="">
            <failure message="openssl: Unbounded memory growth with session handling in TLSv1.3" type="description">Issue summary: Some non-default TLS server configurations can cause unbounded&#xA;memory growth when processing TLSv1.3 sessions&#xA;&#xA;Impact summary: An attacker may exploit certain server configurations to trigger&#xA;unbounded memory growth that would lead to a Denial of Service&#xA;&#xA;This problem can occur in TLSv1.3 if the non-default SSL_OP_NO_TICKET option is&#xA;being used (but not if early_data support is also configured and the default&#xA;anti-replay protection is in use). In this case, under certain conditions, the&#xA;session cache can get into an incorrect state and it will fail to flush properly&#xA;as it fills. The session cache will continue to grow in an unbounded manner. A&#xA;malicious client could deliberately create the scenario for this failure to&#xA;force a Denial of Service. It may also happen by accident in normal operation.&#xA;&#xA;This issue only affects TLS servers supporting TLSv1.3. It does not affect TLS&#xA;clients.&#xA;&#xA;The FIPS modules in 3.2, 3.1 and 3.0 are not affected by this issue. OpenSSL&#xA;1.0.2 is also not affected by this issue.</failure>
        </testcase>
        <testcase classname="libcrypto3-3.0.12-r1" name="[LOW] CVE-2024-9143" time="">
            <failure message="openssl: Low-level invalid GF(2^m) parameters lead to OOB memory access" type="description">Issue summary: Use of the low-level GF(2^m) elliptic curve APIs with untrusted&#xA;explicit values for the field polynomial can lead to out-of-bounds memory reads&#xA;or writes.&#xA;&#xA;Impact summary: Out of bound memory writes can lead to an application crash or&#xA;even a possibility of a remote code execution, however, in all the protocols&#xA;involving Elliptic Curve Cryptography that we&#39;re aware of, either only &#34;named&#xA;curves&#34; are supported, or, if explicit curve parameters are supported, they&#xA;specify an X9.62 encoding of binary (GF(2^m)) curves that can&#39;t represent&#xA;problematic input values. Thus the likelihood of existence of a vulnerable&#xA;application is low.&#xA;&#xA;In particular, the X9.62 encoding is used for ECC keys in X.509 certificates,&#xA;so problematic inputs cannot occur in the context of processing X.509&#xA;certificates.  Any problematic use-cases would have to be using an &#34;exotic&#34;&#xA;curve encoding.&#xA;&#xA;The affected APIs include: EC_GROUP_new_curve_GF2m(), EC_GROUP_new_from_params(),&#xA;and various supporting BN_GF2m_*() functions.&#xA;&#xA;Applications working with &#34;exotic&#34; explicit binary (GF(2^m)) curve parameters,&#xA;that make it possible to represent invalid field polynomials with a zero&#xA;constant term, via the above or similar APIs, may terminate abruptly as a&#xA;result of reading or writing outside of array bounds.  Remote code execution&#xA;cannot easily be ruled out.&#xA;&#xA;The FIPS modules in 3.3, 3.2, 3.1 and 3.0 are not affected by this issue.</failure>
        </testcase>
        <testcase classname="libssl3-3.0.12-r1" name="[HIGH] CVE-2024-6119" time="">
            <failure message="openssl: Possible denial of service in X.509 name checks" type="description">Issue summary: Applications performing certificate name checks (e.g., TLS&#xA;clients checking server certificates) may attempt to read an invalid memory&#xA;address resulting in abnormal termination of the application process.&#xA;&#xA;Impact summary: Abnormal termination of an application can a cause a denial of&#xA;service.&#xA;&#xA;Applications performing certificate name checks (e.g., TLS clients checking&#xA;server certificates) may attempt to read an invalid memory address when&#xA;comparing the expected name with an `otherName` subject alternative name of an&#xA;X.509 certificate. This may result in an exception that terminates the&#xA;application program.&#xA;&#xA;Note that basic certificate chain validation (signatures, dates, ...) is not&#xA;affected, the denial of service can occur only when the application also&#xA;specifies an expected DNS name, Email address or IP address.&#xA;&#xA;TLS servers rarely solicit client certificates, and even when they do, they&#xA;generally don&#39;t perform a name check against a reference identifier (expected&#xA;identity), but rather extract the presented identity after checking the&#xA;certificate chain.  So TLS servers are generally not affected and the severity&#xA;of the issue is Moderate.&#xA;&#xA;The FIPS modules in 3.3, 3.2, 3.1 and 3.0 are not affected by this issue.</failure>
        </testcase>
        <testcase classname="libssl3-3.0.12-r1" name="[MEDIUM] CVE-2023-6129" time="">
            <failure message="openssl: POLY1305 MAC implementation corrupts vector registers on PowerPC" type="description">Issue summary: The POLY1305 MAC (message authentication code) implementation&#xA;contains a bug that might corrupt the internal state of applications running&#xA;on PowerPC CPU based platforms if the CPU provides vector instructions.&#xA;&#xA;Impact summary: If an attacker can influence whether the POLY1305 MAC&#xA;algorithm is used, the application state might be corrupted with various&#xA;application dependent consequences.&#xA;&#xA;The POLY1305 MAC (message authentication code) implementation in OpenSSL for&#xA;PowerPC CPUs restores the contents of vector registers in a different order&#xA;than they are saved. Thus the contents of some of these vector registers&#xA;are corrupted when returning to the caller. The vulnerable code is used only&#xA;on newer PowerPC processors supporting the PowerISA 2.07 instructions.&#xA;&#xA;The consequences of this kind of internal application state corruption can&#xA;be various - from no consequences, if the calling application does not&#xA;depend on the contents of non-volatile XMM registers at all, to the worst&#xA;consequences, where the attacker could get complete control of the application&#xA;process. However unless the compiler uses the vector registers for storing&#xA;pointers, the most likely consequence, if any, would be an incorrect result&#xA;of some application dependent calculations or a crash leading to a denial of&#xA;service.&#xA;&#xA;The POLY1305 MAC algorithm is most frequently used as part of the&#xA;CHACHA20-POLY1305 AEAD (authenticated encryption with associated data)&#xA;algorithm. The most common usage of this AEAD cipher is with TLS protocol&#xA;versions 1.2 and 1.3. If this cipher is enabled on the server a malicious&#xA;client can influence whether this AEAD cipher is used. This implies that&#xA;TLS server applications using OpenSSL can be potentially impacted. However&#xA;we are currently not aware of any concrete application that would be affected&#xA;by this issue therefore we consider this a Low severity security issue.</failure>
        </testcase>
        <testcase classname="libssl3-3.0.12-r1" name="[MEDIUM] CVE-2023-6237" time="">
            <failure message="openssl: Excessive time spent checking invalid RSA public keys" type="description">Issue summary: Checking excessively long invalid RSA public keys may take&#xA;a long time.&#xA;&#xA;Impact summary: Applications that use the function EVP_PKEY_public_check()&#xA;to check RSA public keys may experience long delays. Where the key that&#xA;is being checked has been obtained from an untrusted source this may lead&#xA;to a Denial of Service.&#xA;&#xA;When function EVP_PKEY_public_check() is called on RSA public keys,&#xA;a computation is done to confirm that the RSA modulus, n, is composite.&#xA;For valid RSA keys, n is a product of two or more large primes and this&#xA;computation completes quickly. However, if n is an overly large prime,&#xA;then this computation would take a long time.&#xA;&#xA;An application that calls EVP_PKEY_public_check() and supplies an RSA key&#xA;obtained from an untrusted source could be vulnerable to a Denial of Service&#xA;attack.&#xA;&#xA;The function EVP_PKEY_public_check() is not called from other OpenSSL&#xA;functions however it is called from the OpenSSL pkey command line&#xA;application. For that reason that application is also vulnerable if used&#xA;with the &#39;-pubin&#39; and &#39;-check&#39; options on untrusted data.&#xA;&#xA;The OpenSSL SSL/TLS implementation is not affected by this issue.&#xA;&#xA;The OpenSSL 3.0 and 3.1 FIPS providers are affected by this issue.</failure>
        </testcase>
        <testcase classname="libssl3-3.0.12-r1" name="[MEDIUM] CVE-2024-0727" time="">
            <failure message="openssl: denial of service via null dereference" type="description">Issue summary: Processing a maliciously formatted PKCS12 file may lead OpenSSL&#xA;to crash leading to a potential Denial of Service attack&#xA;&#xA;Impact summary: Applications loading files in the PKCS12 format from untrusted&#xA;sources might terminate abruptly.&#xA;&#xA;A file in PKCS12 format can contain certificates and keys and may come from an&#xA;untrusted source. The PKCS12 specification allows certain fields to be NULL, but&#xA;OpenSSL does not correctly check for this case. This can lead to a NULL pointer&#xA;dereference that results in OpenSSL crashing. If an application processes PKCS12&#xA;files from an untrusted source using the OpenSSL APIs then that application will&#xA;be vulnerable to this issue.&#xA;&#xA;OpenSSL APIs that are vulnerable to this are: PKCS12_parse(),&#xA;PKCS12_unpack_p7data(), PKCS12_unpack_p7encdata(), PKCS12_unpack_authsafes()&#xA;and PKCS12_newpass().&#xA;&#xA;We have also fixed a similar issue in SMIME_write_PKCS7(). However since this&#xA;function is related to writing data we do not consider it security significant.&#xA;&#xA;The FIPS modules in 3.2, 3.1 and 3.0 are not affected by this issue.</failure>
        </testcase>
        <testcase classname="libssl3-3.0.12-r1" name="[MEDIUM] CVE-2024-4603" time="">
            <failure message="openssl: Excessive time spent checking DSA keys and parameters" type="description">Issue summary: Checking excessively long DSA keys or parameters may be very&#xA;slow.&#xA;&#xA;Impact summary: Applications that use the functions EVP_PKEY_param_check()&#xA;or EVP_PKEY_public_check() to check a DSA public key or DSA parameters may&#xA;experience long delays. Where the key or parameters that are being checked&#xA;have been obtained from an untrusted source this may lead to a Denial of&#xA;Service.&#xA;&#xA;The functions EVP_PKEY_param_check() or EVP_PKEY_public_check() perform&#xA;various checks on DSA parameters. Some of those computations take a long time&#xA;if the modulus (`p` parameter) is too large.&#xA;&#xA;Trying to use a very large modulus is slow and OpenSSL will not allow using&#xA;public keys with a modulus which is over 10,000 bits in length for signature&#xA;verification. However the key and parameter check functions do not limit&#xA;the modulus size when performing the checks.&#xA;&#xA;An application that calls EVP_PKEY_param_check() or EVP_PKEY_public_check()&#xA;and supplies a key or parameters obtained from an untrusted source could be&#xA;vulnerable to a Denial of Service attack.&#xA;&#xA;These functions are not called by OpenSSL itself on untrusted DSA keys so&#xA;only applications that directly call these functions may be vulnerable.&#xA;&#xA;Also vulnerable are the OpenSSL pkey and pkeyparam command line applications&#xA;when using the `-check` option.&#xA;&#xA;The OpenSSL SSL/TLS implementation is not affected by this issue.&#xA;&#xA;The OpenSSL 3.0 and 3.1 FIPS providers are affected by this issue.</failure>
        </testcase>
        <testcase classname="libssl3-3.0.12-r1" name="[MEDIUM] CVE-2024-4741" time="">
            <failure message="openssl: Use After Free with SSL_free_buffers" type="description">Issue summary: Calling the OpenSSL API function SSL_free_buffers may cause&#xA;memory to be accessed that was previously freed in some situations&#xA;&#xA;Impact summary: A use after free can have a range of potential consequences such&#xA;as the corruption of valid data, crashes or execution of arbitrary code.&#xA;However, only applications that directly call the SSL_free_buffers function are&#xA;affected by this issue. Applications that do not call this function are not&#xA;vulnerable. Our investigations indicate that this function is rarely used by&#xA;applications.&#xA;&#xA;The SSL_free_buffers function is used to free the internal OpenSSL buffer used&#xA;when processing an incoming record from the network. The call is only expected&#xA;to succeed if the buffer is not currently in use. However, two scenarios have&#xA;been identified where the buffer is freed even when still in use.&#xA;&#xA;The first scenario occurs where a record header has been received from the&#xA;network and processed by OpenSSL, but the full record body has not yet arrived.&#xA;In this case calling SSL_free_buffers will succeed even though a record has only&#xA;been partially processed and the buffer is still in use.&#xA;&#xA;The second scenario occurs where a full record containing application data has&#xA;been received and processed by OpenSSL but the application has only read part of&#xA;this data. Again a call to SSL_free_buffers will succeed even though the buffer&#xA;is still in use.&#xA;&#xA;While these scenarios could occur accidentally during normal operation a&#xA;malicious attacker could attempt to engineer a stituation where this occurs.&#xA;We are not aware of this issue being actively exploited.&#xA;&#xA;The FIPS modules in 3.3, 3.2, 3.1 and 3.0 are not affected by this issue.</failure>
        </testcase>
        <testcase classname="libssl3-3.0.12-r1" name="[MEDIUM] CVE-2024-5535" time="">
            <failure message="openssl: SSL_select_next_proto buffer overread" type="description">Issue summary: Calling the OpenSSL API function SSL_select_next_proto with an&#xA;empty supported client protocols buffer may cause a crash or memory contents to&#xA;be sent to the peer.&#xA;&#xA;Impact summary: A buffer overread can have a range of potential consequences&#xA;such as unexpected application beahviour or a crash. In particular this issue&#xA;could result in up to 255 bytes of arbitrary private data from memory being sent&#xA;to the peer leading to a loss of confidentiality. However, only applications&#xA;that directly call the SSL_select_next_proto function with a 0 length list of&#xA;supported client protocols are affected by this issue. This would normally never&#xA;be a valid scenario and is typically not under attacker control but may occur by&#xA;accident in the case of a configuration or programming error in the calling&#xA;application.&#xA;&#xA;The OpenSSL API function SSL_select_next_proto is typically used by TLS&#xA;applications that support ALPN (Application Layer Protocol Negotiation) or NPN&#xA;(Next Protocol Negotiation). NPN is older, was never standardised and&#xA;is deprecated in favour of ALPN. We believe that ALPN is significantly more&#xA;widely deployed than NPN. The SSL_select_next_proto function accepts a list of&#xA;protocols from the server and a list of protocols from the client and returns&#xA;the first protocol that appears in the server list that also appears in the&#xA;client list. In the case of no overlap between the two lists it returns the&#xA;first item in the client list. In either case it will signal whether an overlap&#xA;between the two lists was found. In the case where SSL_select_next_proto is&#xA;called with a zero length client list it fails to notice this condition and&#xA;returns the memory immediately following the client list pointer (and reports&#xA;that there was no overlap in the lists).&#xA;&#xA;This function is typically called from a server side application callback for&#xA;ALPN or a client side application callback for NPN. In the case of ALPN the list&#xA;of protocols supplied by the client is guaranteed by libssl to never be zero in&#xA;length. The list of server protocols comes from the application and should never&#xA;normally be expected to be of zero length. In this case if the&#xA;SSL_select_next_proto function has been called as expected (with the list&#xA;supplied by the client passed in the client/client_len parameters), then the&#xA;application will not be vulnerable to this issue. If the application has&#xA;accidentally been configured with a zero length server list, and has&#xA;accidentally passed that zero length server list in the client/client_len&#xA;parameters, and has additionally failed to correctly handle a &#34;no overlap&#34;&#xA;response (which would normally result in a handshake failure in ALPN) then it&#xA;will be vulnerable to this problem.&#xA;&#xA;In the case of NPN, the protocol permits the client to opportunistically select&#xA;a protocol when there is no overlap. OpenSSL returns the first client protocol&#xA;in the no overlap case in support of this. The list of client protocols comes&#xA;from the application and should never normally be expected to be of zero length.&#xA;However if the SSL_select_next_proto function is accidentally called with a&#xA;client_len of 0 then an invalid memory pointer will be returned instead. If the&#xA;application uses this output as the opportunistic protocol then the loss of&#xA;confidentiality will occur.&#xA;&#xA;This issue has been assessed as Low severity because applications are most&#xA;likely to be vulnerable if they are using NPN instead of ALPN - but NPN is not&#xA;widely used. It also requires an application configuration or programming error.&#xA;Finally, this issue would not typically be under attacker control making active&#xA;exploitation unlikely.&#xA;&#xA;The FIPS modules in 3.3, 3.2, 3.1 and 3.0 are not affected by this issue.&#xA;&#xA;Due to the low severity of this issue we are not issuing new releases of&#xA;OpenSSL at this time. The fix will be included in the next releases when they&#xA;become available.</failure>
        </testcase>
        <testcase classname="libssl3-3.0.12-r1" name="[LOW] CVE-2024-2511" time="">
            <failure message="openssl: Unbounded memory growth with session handling in TLSv1.3" type="description">Issue summary: Some non-default TLS server configurations can cause unbounded&#xA;memory growth when processing TLSv1.3 sessions&#xA;&#xA;Impact summary: An attacker may exploit certain server configurations to trigger&#xA;unbounded memory growth that would lead to a Denial of Service&#xA;&#xA;This problem can occur in TLSv1.3 if the non-default SSL_OP_NO_TICKET option is&#xA;being used (but not if early_data support is also configured and the default&#xA;anti-replay protection is in use). In this case, under certain conditions, the&#xA;session cache can get into an incorrect state and it will fail to flush properly&#xA;as it fills. The session cache will continue to grow in an unbounded manner. A&#xA;malicious client could deliberately create the scenario for this failure to&#xA;force a Denial of Service. It may also happen by accident in normal operation.&#xA;&#xA;This issue only affects TLS servers supporting TLSv1.3. It does not affect TLS&#xA;clients.&#xA;&#xA;The FIPS modules in 3.2, 3.1 and 3.0 are not affected by this issue. OpenSSL&#xA;1.0.2 is also not affected by this issue.</failure>
        </testcase>
        <testcase classname="libssl3-3.0.12-r1" name="[LOW] CVE-2024-9143" time="">
            <failure message="openssl: Low-level invalid GF(2^m) parameters lead to OOB memory access" type="description">Issue summary: Use of the low-level GF(2^m) elliptic curve APIs with untrusted&#xA;explicit values for the field polynomial can lead to out-of-bounds memory reads&#xA;or writes.&#xA;&#xA;Impact summary: Out of bound memory writes can lead to an application crash or&#xA;even a possibility of a remote code execution, however, in all the protocols&#xA;involving Elliptic Curve Cryptography that we&#39;re aware of, either only &#34;named&#xA;curves&#34; are supported, or, if explicit curve parameters are supported, they&#xA;specify an X9.62 encoding of binary (GF(2^m)) curves that can&#39;t represent&#xA;problematic input values. Thus the likelihood of existence of a vulnerable&#xA;application is low.&#xA;&#xA;In particular, the X9.62 encoding is used for ECC keys in X.509 certificates,&#xA;so problematic inputs cannot occur in the context of processing X.509&#xA;certificates.  Any problematic use-cases would have to be using an &#34;exotic&#34;&#xA;curve encoding.&#xA;&#xA;The affected APIs include: EC_GROUP_new_curve_GF2m(), EC_GROUP_new_from_params(),&#xA;and various supporting BN_GF2m_*() functions.&#xA;&#xA;Applications working with &#34;exotic&#34; explicit binary (GF(2^m)) curve parameters,&#xA;that make it possible to represent invalid field polynomials with a zero&#xA;constant term, via the above or similar APIs, may terminate abruptly as a&#xA;result of reading or writing outside of array bounds.  Remote code execution&#xA;cannot easily be ruled out.&#xA;&#xA;The FIPS modules in 3.3, 3.2, 3.1 and 3.0 are not affected by this issue.</failure>
        </testcase>
        <testcase classname="ssl_client-1.35.0-r29" name="[MEDIUM] CVE-2023-42363" time="">
            <failure message="busybox: use-after-free in awk" type="description">A use-after-free vulnerability was discovered in xasprintf function in xfuncs_printf.c:344 in BusyBox v.1.36.1.</failure>
        </testcase>
        <testcase classname="ssl_client-1.35.0-r29" name="[MEDIUM] CVE-2023-42364" time="">
            <failure message="busybox: use-after-free" type="description">A use-after-free vulnerability in BusyBox v.1.36.1 allows attackers to cause a denial of service via a crafted awk pattern in the awk.c evaluate function.</failure>
        </testcase>
        <testcase classname="ssl_client-1.35.0-r29" name="[MEDIUM] CVE-2023-42365" time="">
            <failure message="busybox: use-after-free" type="description">A use-after-free vulnerability was discovered in BusyBox v.1.36.1 via a crafted awk pattern in the awk.c copyvar function.</failure>
        </testcase>
        <testcase classname="ssl_client-1.35.0-r29" name="[MEDIUM] CVE-2023-42366" time="">
            <failure message="busybox: A heap-buffer-overflow" type="description">A heap-buffer-overflow was discovered in BusyBox v.1.36.1 in the next_token function at awk.c:1159.</failure>
        </testcase>
    </testsuite>
    <testsuite tests="0" failures="0" name="mohamed710/solar-system-gitea:62961a6bc2e8a26ec53be66fb435fe2773f8302e (alpine 3.17.6)" errors="0" skipped="0" time="">
        <properties>
            <property name="type" value="alpine"></property>
        </properties>
    </testsuite>
    <testsuite tests="15" failures="15" name="Node.js" errors="0" skipped="0" time="">
        <properties>
            <property name="type" value="node-pkg"></property>
        </properties>
        <testcase classname="body-parser-1.20.1" name="[HIGH] CVE-2024-45590" time="">
            <failure message="body-parser: Denial of Service Vulnerability in body-parser" type="description">body-parser is Node.js body parsing middleware. body-parser &lt;1.20.3 is vulnerable to denial of service when url encoding is enabled. A malicious actor using a specially crafted payload could flood the server with a large number of requests, resulting in denial of service. This issue is patched in 1.20.3.</failure>
        </testcase>
        <testcase classname="brace-expansion-1.1.11" name="[LOW] CVE-2025-5889" time="">
            <failure message="brace-expansion: juliangruber brace-expansion index.js expand redos" type="description">A vulnerability was found in juliangruber brace-expansion up to 1.1.11/2.0.1/3.0.0/4.0.0. It has been rated as problematic. Affected by this issue is the function expand of the file index.js. The manipulation leads to inefficient regular expression complexity. The attack may be launched remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. Upgrading to version 1.1.12, 2.0.2, 3.0.1 and 4.0.1 is able to address this issue. The name of the patch is a5b98a4f30d7813266b221435e1eaaf25a1b0ac5. It is recommended to upgrade the affected component.</failure>
        </testcase>
        <testcase classname="brace-expansion-1.1.11" name="[LOW] CVE-2025-5889" time="">
            <failure message="brace-expansion: juliangruber brace-expansion index.js expand redos" type="description">A vulnerability was found in juliangruber brace-expansion up to 1.1.11/2.0.1/3.0.0/4.0.0. It has been rated as problematic. Affected by this issue is the function expand of the file index.js. The manipulation leads to inefficient regular expression complexity. The attack may be launched remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. Upgrading to version 1.1.12, 2.0.2, 3.0.1 and 4.0.1 is able to address this issue. The name of the patch is a5b98a4f30d7813266b221435e1eaaf25a1b0ac5. It is recommended to upgrade the affected component.</failure>
        </testcase>
        <testcase classname="brace-expansion-2.0.1" name="[LOW] CVE-2025-5889" time="">
            <failure message="brace-expansion: juliangruber brace-expansion index.js expand redos" type="description">A vulnerability was found in juliangruber brace-expansion up to 1.1.11/2.0.1/3.0.0/4.0.0. It has been rated as problematic. Affected by this issue is the function expand of the file index.js. The manipulation leads to inefficient regular expression complexity. The attack may be launched remotely. The complexity of an attack is rather high. The exploitation is known to be difficult. The exploit has been disclosed to the public and may be used. Upgrading to version 1.1.12, 2.0.2, 3.0.1 and 4.0.1 is able to address this issue. The name of the patch is a5b98a4f30d7813266b221435e1eaaf25a1b0ac5. It is recommended to upgrade the affected component.</failure>
        </testcase>
        <testcase classname="cookie-0.5.0" name="[LOW] CVE-2024-47764" time="">
            <failure message="cookie: cookie accepts cookie name, path, and domain with out of bounds characters" type="description">cookie is a basic HTTP cookie parser and serializer for HTTP servers. The cookie name could be used to set other fields of the cookie, resulting in an unexpected cookie value. A similar escape can be used for path and domain, which could be abused to alter other fields of the cookie. Upgrade to 0.7.0, which updates the validation for name, path, and domain.</failure>
        </testcase>
        <testcase classname="cross-spawn-7.0.3" name="[HIGH] CVE-2024-21538" time="">
            <failure message="cross-spawn: regular expression denial of service" type="description">Versions of the package cross-spawn before 6.0.6, from 7.0.0 and before 7.0.5 are vulnerable to Regular Expression Denial of Service (ReDoS) due to improper input sanitization. An attacker can increase the CPU usage and crash the program by crafting a very large and well crafted string.</failure>
        </testcase>
        <testcase classname="express-4.18.2" name="[MEDIUM] CVE-2024-29041" time="">
            <failure message="express: cause malformed URLs to be evaluated" type="description">Express.js minimalist web framework for node. Versions of Express.js prior to 4.19.0 and all pre-release alpha and beta versions of 5.0 are affected by an open redirect vulnerability using malformed URLs. When a user of Express performs a redirect using a user-provided URL Express performs an encode [using `encodeurl`](https://github.com/pillarjs/encodeurl) on the contents before passing it to the `location` header. This can cause malformed URLs to be evaluated in unexpected ways by common redirect allow list implementations in Express applications, leading to an Open Redirect via bypass of a properly implemented allow list. The main method impacted is `res.location()` but this is also called from within `res.redirect()`. The vulnerability is fixed in 4.19.2 and 5.0.0-beta.3.</failure>
        </testcase>
        <testcase classname="express-4.18.2" name="[LOW] CVE-2024-43796" time="">
            <failure message="express: Improper Input Handling in Express Redirects" type="description">Express.js minimalist web framework for node. In express &lt; 4.20.0, passing untrusted user input - even after sanitizing it - to response.redirect() may execute untrusted code. This issue is patched in express 4.20.0.</failure>
        </testcase>
        <testcase classname="ip-2.0.0" name="[HIGH] CVE-2024-29415" time="">
            <failure message="node-ip: Incomplete fix for CVE-2023-42282" type="description">The ip package through 2.0.1 for Node.js might allow SSRF because some IP addresses (such as 127.1, 01200034567, 012.1.2.3, 000:0:0000::01, and ::fFFf:127.0.0.1) are improperly categorized as globally routable via isPublic. NOTE: this issue exists because of an incomplete fix for CVE-2023-42282.</failure>
        </testcase>
        <testcase classname="ip-2.0.0" name="[LOW] CVE-2023-42282" time="">
            <failure message="nodejs-ip: arbitrary code execution via the isPublic() function" type="description">The ip package before 1.1.9 for Node.js might allow SSRF because some IP addresses (such as 0x7f.1) are improperly categorized as globally routable via isPublic.</failure>
        </testcase>
        <testcase classname="path-to-regexp-0.1.7" name="[HIGH] CVE-2024-45296" time="">
            <failure message="path-to-regexp: Backtracking regular expressions cause ReDoS" type="description">path-to-regexp turns path strings into a regular expressions. In certain cases, path-to-regexp will output a regular expression that can be exploited to cause poor performance. Because JavaScript is single threaded and regex matching runs on the main thread, poor performance will block the event loop and lead to a DoS. The bad regular expression is generated any time you have two parameters within a single segment, separated by something that is not a period (.). For users of 0.1, upgrade to 0.1.10. All other users should upgrade to 8.0.0.</failure>
        </testcase>
        <testcase classname="path-to-regexp-0.1.7" name="[HIGH] CVE-2024-52798" time="">
            <failure message="path-to-regexp: path-to-regexp Unpatched `path-to-regexp` ReDoS in 0.1.x" type="description">path-to-regexp turns path strings into a regular expressions. In certain cases, path-to-regexp will output a regular expression that can be exploited to cause poor performance. The regular expression that is vulnerable to backtracking can be generated in the 0.1.x release of path-to-regexp. Upgrade to 0.1.12. This vulnerability exists because of an incomplete fix for CVE-2024-45296.</failure>
        </testcase>
        <testcase classname="send-0.18.0" name="[LOW] CVE-2024-43799" time="">
            <failure message="send: Code Execution Vulnerability in Send Library" type="description">Send is a library for streaming files from the file system as a http response. Send passes untrusted user input to SendStream.redirect() which executes untrusted code. This issue is patched in send 0.19.0.</failure>
        </testcase>
        <testcase classname="serve-static-1.15.0" name="[LOW] CVE-2024-43800" time="">
            <failure message="serve-static: Improper Sanitization in serve-static" type="description">serve-static serves static files. serve-static passes untrusted user input - even after sanitizing it - to redirect() may execute untrusted code. This issue is patched in serve-static 1.16.0.</failure>
        </testcase>
        <testcase classname="tar-6.2.0" name="[MEDIUM] CVE-2024-28863" time="">
            <failure message="node-tar: denial of service while parsing a tar file due to lack of folders depth validation" type="description">node-tar is a Tar for Node.js. node-tar prior to version 6.2.1 has no limit on the number of sub-folders created in the folder creation process. An attacker who generates a large number of sub-folders can consume memory on the system running node-tar and even crash the Node.js client within few seconds of running it using a path with too many sub-folders inside. Version 6.2.1 fixes this issue by preventing extraction in excessively deep sub-folders.</failure>
        </testcase>
    </testsuite>
    <testsuite tests="0" failures="0" name="Node.js" errors="0" skipped="0" time="">
        <properties>
            <property name="type" value="node-pkg"></property>
        </properties>
    </testsuite>
</testsuites>
